#include "hpp.hpp"

#define YYERR "\n\n"<<yylineno<<":"<<msg<<"["<<yytext<<"]\n\n"
void yyerror(std::string msg) { std::cout<<YYERR; std::cerr<<YYERR; exit(-1); }
int main() { env_init(); return yyparse(); }

std::map<std::string,AST*> env;
void env_init() {
	env["nil"]=nil;
	// ----------------------------------------------- metainfo constants
	env["AUTHOR"]	= new Str(AUTHOR);					// author (c)
	env["LICENSE"]	= new Str(LICENSE);					// license
	env["GITHUB"]	= new Str(GITHUB);					// github home
	env["AUTOGEN"]	= new Str(AUTOGEN);					// autogenerated code signature
	env["LOGO"]		= new Str(LOGO);					// bI logo (w/o file extension)
	env["LISPLOGO"]	= new Str(LISPLOGO);				// Lisp Warning logo
	// functions
	fn_init();
}

void W(AST*o)			{ std::cout << o->dump(); }		// == writers ==
void W(std::string s)	{ std::cout << s; }

AST::AST(std::string T,std::string V)	{ tag=T; val=V; }	// <T:V> constuctor
void AST::push(AST*o)					{ nest.push_back(o); }
void AST::setpar(AST*o)					{ par[o->val]=o; }

std::string AST::pad(int n) { std::string S; for(int i=0;i<n;i++) S+="\t"; return S; }
std::string AST::tagval()	{ return "<"+tag+":"+val+">"; }	// <tag:val> header
std::string AST::dump(int depth) {							// dump symbol object
	std::string S = "\n"+pad(depth)+tagval();				// header
	for (auto pr=par.begin() ; pr!=par.end() ; pr++)		// walk over par{}ameters
		S += ","+pr->first+":"+pr->second->tagval();
	for (auto it=nest.begin() ; it!=nest.end() ; it++)		// walk over nest[]ed
		S += (*it)->dump(depth+1);
	return S;
}

AST* AST::eval() {
	AST*E = env[val]; if (E) return E;					// eval: lookup
	for (auto it=nest.begin() ; it!=nest.end() ; it++)
		(*it) = (*it)->eval();
	return this;
}
														// == AST operators ==
AST* AST::eq(AST*o)		{ env[o->val]=o;				// AST = AST
	if (o->tag=="^") o->val=val; return o; }			// rename lambda {B}
AST* AST::at(AST*o)		{ push(o); return this; }		// AST @ AST
AST* AST::dot(AST*)		{ return this; }				// AST . AST
AST* AST::neg()			{ val="-"+val; return this; }	// -AST
AST* AST::add(AST*)		{ return this; }				// +
AST* AST::sub(AST*)		{ return this; }				// -
AST* AST::mul(AST*)		{ return this; }				// *
AST* AST::div(AST*)		{ return this; }				// /
AST* AST::pow(AST*)		{ return this; }				// ^

														// == specials ==
AST* nil = new AST("nil","");							
														// == scalars ==
Sym::Sym(std::string V):AST("sym",V)	{}				// symbol

Str::Str(std::string V):AST("str",V)	{}				// 'string'
std::string Str::tagval() { return "<"+tag+":'"+val+"'>"; }

														// integer
Int::Int(std::string V):AST("int","")	{ val = atoi(V.c_str()); }
AST* Int::neg()							{ val = -val; return this; }// -Int
std::string Int::tagval() {
	std::ostringstream os; os<<"<"<<tag<<":"<<val<<">"; return os.str(); }

Hex::Hex(std::string V):AST("hex",V)	{}				// machine hex
Bin::Bin(std::string V):AST("bin",V)	{}				// machine binary

														// floting number
Num::Num(std::string V):AST("num","")	{ val = atof(V.c_str()); }
std::string Num::tagval() {
	std::ostringstream os; os<<"<"<<tag<<":"<<val<<">"; return os.str(); }
AST* Num::neg()							{ val = -val; return this; }// -Num

														// == composites ==
List::List():AST("[","]") {}							// [list]
Vector::Vector():AST("","") {}							// <vector>
Tuple::Tuple(AST*A,AST*B):AST(",",",") {				// tu,ple
	push(A); push(B);
	}
Pair::Pair(AST*A,AST*B):AST("","") {					// pa:ir
	tag=A->val; push(A); val=B->val; push(B); }
														// == functionals ==
Op::Op(std::string V):AST("op",V) {}					// operator
AST* Op::eval() {
	AST::eval();										// nest[]ed evaluate
	if (nest.size()==2) {								// A op B bin.operator
		if (val=="=") return nest[0]->eq(nest[1]);
	}
	return this;
}

Lambda::Lambda():AST("^","^") {}						// {lambda}

void fn_init(){											// == init functions ==
}
