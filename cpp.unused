														// == AST operators ==
AST* AST::eq(AST*o)		{ env[o->val]=o;				// AST = AST
	if (o->tag=="^") o->val=val; return o; }			// rename lambda {B}
AST* AST::at(AST*o)		{ push(o); return this; }		// AST @ AST
AST* AST::dot(AST*)		{ return this; }				// AST . AST
AST* AST::neg()			{ val="-"+val; return this; }	// -AST
AST* AST::add(AST*)		{ return this; }				// +
AST* AST::sub(AST*)		{ return this; }				// -
AST* AST::mul(AST*)		{ return this; }				// *
AST* AST::div(AST*)		{ return this; }				// /
AST* AST::pow(AST*)		{ return this; }				// ^

														// == functionals ==
AST* Op::eval() {
	AST::eval();										// nest[]ed evaluate
	if (nest.size()==2) {								// A op B bin.operator
		if (val=="=") return nest[0]->eq(nest[1]);
	}
	return this;
}

