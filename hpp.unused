
extern std::map<std::string,AST*> env;					// == global environment ==
extern void env_init();									// init env[] on startup
extern void fn_init();									// internal functions 

extern void W(AST*);									// == writers ==
extern void W(std::string);
														// == lexer interface ==
extern int yylex();										// parse next token
extern int yylineno;									// current source line
extern char* yytext;									// found token text
#define TOC(C,X) { yylval.o = new C(yytext); return X; }// token macro used in lexer

														// == parser interface ==
extern int yyparse();									// run parser
extern void yyerror(std::string);						// error callback
#include "ypp.tab.hpp"									// token defines for lexer

														// == specials ==
extern AST* nil;										// nil

														// == scalars ==
struct Sym:AST { Sym(std::string); };					// generic symbol
struct Str:AST { Str(std::string); 						// string
	std::string tagval(); };
struct Int:AST { Int(std::string); long   val;			// integer
	std::string tagval(); AST*neg(); };
struct Hex:AST { Hex(std::string); };					// hex machine number
struct Bin:AST { Bin(std::string); };					// binary machine number
struct Num:AST { Num(std::string); double val;			// floating point number
	std::string tagval(); AST*neg(); };
														// == composites ==
struct List:AST { List(); };							// [list]
struct Vector:AST { Vector(); };						// <vector>
struct Pair:AST { Pair(AST*,AST*); };					// pa:ir
struct Tuple:AST { Tuple(AST*,AST*); };					// tu,ple

														// == functionals ==
struct Op:AST { Op(std::string); AST* eval(); };		// operator
struct Lambda:AST { Lambda(); };						// {lambda}
typedef AST*(*FN)(AST*);								// function ptr
struct Fn:AST { Fn(std::string,FN); FN fn; };			// internal function

														// == OS specific ==
#ifdef __MINGW32__
#include "mingw32.hpp"									// win32/MinGW
#endif

