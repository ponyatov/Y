\secrel{Sym: Abstract Symbolic Type}\label{sym}

\bi\ language based on operations on 
\termdef{abstract symbolic type}{Abstract [Sym]bolic Type}:
it's close to classical Abstract Syntax Tree elements, and 
uses same acronim. 
For dymanic languages Sym much complicated comparing
to \lisp\ ceils/lists, and scalar primitive types\note{numbers, strings},
but it was selected considering primary \bi\ area:
computer language processing, where annotated AST trees is basic data type.

\bigskip
\begin{tabular}{l l l}
\verb|class:Sym| && \term{abstract symbolic type} \\
\hline
& \verb|string:tag| & type, class tag \\
& \verb|string:val| & value \\
\hline
\verb|constructors:| & \verb|Sym(string,string)| & \verb|<T:V>|\ constructor \\
& \verb|Sym(string)| & token constructor \\
& \verb|Sym(Sym)| & copy constructor \\
\hline
\verb|nest[]ed:| & \verb|List<Sym>:nest[]| & nested elements \\
& \verb|fn:push(Sym)| & add nested \\
\hline
\verb|par{}ameters:| & \verb|Dict<string,Sym>:par[]| & parameters dict (string-keyed list) \\
& \verb|fn:setpar(Sym)| & add/set parameter \\
\hline
\verb|dump:| & \verb|fn:dump(int)->string| & recursive \verb|dump(+1)|\ tree in text
form (with depth padding) \\
& \verb|fn:tagval()->string| & dump \verb|<T:V>| header only \\
& \verb|fn:pad(int)->string| & return padding string: n tabs \\
\hline
& \verb|fn:eval()->Sym| & compute/evaluate object \\
\verb|operators:| & \verb|op:@(Sym)->Sym| & \verb|A @ B|\ apply \\
& \verb|op:=(Sym)->Sym| & \verb|A = B|\ equal \\
\end{tabular} 

\lst{hpp.hpp}{tmp/hpp.ast}{C++}

Using \term{virtual base class}\ \verb|Sym{}|\ allows to use RTTI and process
inherited class instances using pointers to base class, first of all it allows
to use storage collections \verb|vector<Sym*>|\ and
\verb|map<string,Sym*>|\ for any objects\note{instances of inherited
classes}.  

\secrel{Writers}

Writer\ --- function writes argument to \bi\ log (\verb|.blog|):

\lst{hpp.hpp}{tmp/hpp.wrt}{C++}

\lst{cpp.cpp}{tmp/cpp.wrt}{C++}

