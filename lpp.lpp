%{
#include "hpp.hpp"
string StringLexBuffer;				/* string parsing buffer */
%}
%option noyywrap
%option yylineno
									/* lexer state: string parsing mode */
%x lexstring
									/* lexer state: #| block comment |# */
%x lexcomment
									/* optional number sign */
S [\+\-]?
									/* decimal number digit(s) */
N [0-9]+
%%
#[^\|][^\n]*\n		{}						/* line comment */
#\|					{BEGIN(lexcomment);}	/* block comment*/
<lexcomment>\|#		{BEGIN(INITIAL);}
<lexcomment>\n		{}
<lexcomment>.		{}

'					{BEGIN(lexstring);StringLexBuffer="";}	/* string parser */
<lexstring>'		{BEGIN(INITIAL);
					yylval.o = new Str(StringLexBuffer); return STR; }
<lexstring>.		{StringLexBuffer+=yytext[0];}

									/* numbers: */
{S}{N}				TOC(Int,NUM)	/* integer */
0x[0-9A-F]+			TOC(Hex,NUM)	/* machine hex */
0b[01]+				TOC(Bin,NUM)	/* machine binary */
{S}{N}\.{N}			TOC(Num,NUM)	/* float */
{S}{N}[eE]{S}{N}	TOC(Num,NUM)	/* exponential */

[a-zA-Z0-9_]+		TOC(Sym,SYM)	/* symbol */

									/* parens */
\(					TOC(Op,LP)
\)					TOC(Op,RP)
\[					TOC(Op,LQ)
\]					TOC(Op,RQ)
\{					TOC(Op,LB)
\}					TOC(Op,RB)
									/* operators */
\=					TOC(Op,EQ)							
\@					TOC(Op,AT)
\.					TOC(Op,DOT)
\:					TOC(Op,COLON)

[ \t\r\n]+			{}				/* drop spaces */
.					{}				/* drop undetected chars */
%%
