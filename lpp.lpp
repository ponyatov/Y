%{
#include "../hpp.hpp"
string LexString;											// string buffer
void incLude(Sym*inc) {										// .inc processing
	if (!(yyin = fopen(inc->val.c_str(),"r"))) yyerror("");	// open
	yypush_buffer_state(yy_create_buffer(yyin,YY_BUF_SIZE));// push to lexer
}
%}
%option noyywrap
%option yylineno
								/* extra lexer states: string/docstring parsing */
%x lexstring docstring
								/* optional sign in numbers */
S [\+\-]?
								/* decimal number digit(s) */
N [0-9]+
%%
#[^\n]*				{}						/* line comment */

^\.inc[ \t]+[^\n]*	{incLude(new Directive(yytext));}		/* .include */

'					{BEGIN(lexstring);LexString="";}		/* string parser */
<lexstring>'		{BEGIN(INITIAL);
					yylval.o = new Str(LexString); return STR; }
<lexstring>\\t		{LexString+='\t';}
<lexstring>\\n		{LexString+='\n';}
<lexstring>.		{LexString+=yytext[0];}

\"					{BEGIN(docstring);LexString="";}		/* docstring */
<docstring>\"		{BEGIN(INITIAL);
					yylval.o = new Str(LexString); return DOC; }
<docstring>\\t		{LexString+='\t';}
<docstring>\\n		{LexString+='\n';}
<docstring>.		{LexString+=yytext[0];}

											/* numbers */
{S}{N}				TOC(Int,NUM)			/* integer */

^\.[a-z]+			TOC(Directive,DIR)		/* .directive */
[a-zA-Z0-9_]+		TOC(Sym,SYM)			/* symbol */

											/* brackets */
\(					TOC(Op,L)
\)					TOC(Op,R)
\[					TOC(Op,LQ)
\]					TOC(Op,RQ)
\{					TOC(Op,LB)
\}					TOC(Op,RB)
											/* operators */
\.					TOC(Op,DOT)
\=					TOC(Op,EQ)
\@					TOC(Op,AT)
\:					TOC(Op,COLON)

\+					TOC(Op,ADD)
\-					TOC(Op,SUB)
\*					TOC(Op,MUL)
\/					TOC(Op,DIV)
\^					TOC(Op,DIV)

\+=					TOC(Op,INS)
\-=					TOC(Op,DEL)

[ \t\r\n]+			{}						/* drop spaces */
.					{}						/* drop undetected chars */

<<EOF>>				{ yypop_buffer_state();	/* end of .inluded file */
					if (!YY_CURRENT_BUFFER) yyterminate();}
%%
