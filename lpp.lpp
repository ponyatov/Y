/***** DO NOT EDIT: this file was autogened by bI *****/
%{
#include "hpp.hpp"
string StrBuf;										/* string parsing buffer */
void incFile(sym* inc) {							/* .inc processing */
	yyin = fopen(inc->value.c_str(),"r");
	if (!yyin) yyerror(inc->tagval());
	yypush_buffer_state(yy_create_buffer(yyin,YY_BUF_SIZE));
}
%}
%option noyywrap
%option yylineno
					/* number sign */
S [\-\+]?
					/* decimal number */
N [0-9]+
					/* directive tail part (after .directive till line end ) */
D [ \t]*[^\n]*
					/* expression parsing state */
%x xx
					/* string parsing state */
%x ss
%%

\\.					T1(CHAR)			/* \-escaped char*/

<*>^#[^\n]*\n+		{W(yytext,false);}	/* full line comment with EOLs */
<*>#[^\n]*			{W(yytext,false);}	/* comment at rest line */

^\.end				{W(new Directive(yytext),false);yyterminate();}
^\.module{D}		TX(Directive,MODULE)
^\.file{D}			TX(Directive,FFILE)
^\.eof				TX(Directive,FEOF)
^\.inc{D}			TX(Directive,INC)
^\.[a-z]+{D}		TX(Directive,DIRECTIVE)

\$					{BEGIN(xx);TC(SX);}	/* expression mode on: inline str*/
\?					{BEGIN(xx);TC(QX);}	/* expression mode on: debug dump */
<xx>[\$\?]			{BEGIN(INITIAL);}	/* expression mode off (inline) */
<xx>[ \t\r\n]+		{}					/* drop spaces in expression mode */

										/* numbers */
<xx>{S}{N}\.{N}[eE]{S}{N}	TX(Num,NUM)	/* exponential */
<xx>{S}{N}[eE]{S}{N}		TX(Num,NUM)	/* exponential */
<xx>{S}{N}\.{N}				TX(Num,NUM)	/* float */
<xx>{S}{N}					TX(Int,NUM)	/* integer */
<xx>0x[0-9A-F]+				TX(Hex,NUM)	/* hexadecimal int */
<xx>0b[01]+					TX(Bin,NUM)	/* binary int */

<xx>'[^']*'			TX(Str,STR)			/* string */
<xx>[a-zA-Z0-9_]+	TO("sym",SYM)		/* symbol */
<xx>\%[TFNE\%]		TO("sym",SYM)		/* specials */

										/* operators */
<xx>\=				TC(EQ)				/* some = value */
<xx>\[				TC(LQ)				/* [list begin */
<xx>\]				TC(RQ)				/* list end]   */
<xx>\(				TC(LP)				/* (grouping begin */
<xx>\)				TC(RP)				/*  grouping end) */
<xx>\<				TC(LL)				/* <vector begin */
<xx>\>				TC(GG)				/*  vector end>  */
<xx>\:				TC(COLON)			/* some:pair */
<xx>\{				TC(BL)				/* {block begin */
<xx>\}				TC(BR)				/*  block end}  */

\n					TC(CHAR)			/* line end */
.					TC(CHAR)			/* any undetected char */

<<EOF>>		{ yypop_buffer_state();		/* end of .inluded file */
			if ( !YY_CURRENT_BUFFER )
				yyterminate();}
%%

