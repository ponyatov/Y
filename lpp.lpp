%{
#include "hpp.hpp"

void incFile(sym* inc) {
	yyin = fopen(inc->value.c_str(),"r");
	if (!yyin) yyerror(inc->tagval());
	yypush_buffer_state(yy_create_buffer(yyin,YY_BUF_SIZE));
}
%}

%option noyywrap
%option yylineno

DF	[ \t]*[^ #\n]*
DR	[ \t]*[^#\n]*
S	[\+\-]?
D	[0-9]+

		/* expression state */
%x xx
%%
\\.					T1(CHAR)
<*>^#[^\n]*\n		{}
<*>#[^\n]*			{}

^\.module{DF}		TX(Directive,MODULE)
^\.file{DF}			TX(Directive,FFILE)
^\.eof				TX(Directive,FEOF)
^\.inc{DF}			TX(Directive,INC)
^\.end				{yyterminate();}
^\.[a-z]+{DR}		TX(Directive,DIRECTIVE)

\@					{BEGIN(xx);TC(AX);}
\$					{BEGIN(xx);TC(SX);}
\?					{BEGIN(xx);TC(QX);}
<xx>\n				{BEGIN(INITIAL);}
<xx>[ \t\r]+			W(yytext,false);
<xx>[@$?]			{BEGIN(INITIAL);}

<xx>{S}{D}			TX(Int,NUM)
<xx>0x[0-9A-F]+		TO("hex",NUM)
<xx>0b[01]+			TO("bin",NUM)
<xx>{S}{D}\.{D}		TX(Num,NUM)
<xx>{S}{D}[eE]{S}{D}	TX(Num,NUM)

<xx>\+				TX(Op,ADD)
<xx>\-				TX(Op,SUB)
<xx>\*				TX(Op,MUL)
<xx>\/				TX(Op,DIV)
<xx>\^				TX(Op,POW)
<xx>\<				TX(Op,LL)
<xx>\>				TX(Op,GG)
<xx>\:				TX(Op,COLON)
<xx>\.				TX(Op,DOT)

<xx>\'[^\']*\'		TX(Str,STR)
<xx>\"[^\"]*\"		TX(Str,STR)
<xx>[a-zA-Z0-9_]+	TO("sym",SYM)
<xx>\%[TFNE]			TO("sym",SYM)

<xx>\[		TX(Op,LQ)
<xx>\]		TX(Op,RQ)

\n			TC(CHAR)
.			TC(CHAR)

<<EOF>>	{ yypop_buffer_state(); if ( !YY_CURRENT_BUFFER ) yyterminate();}
%%
