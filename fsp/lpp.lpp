%{
#include "hpp.hpp"
string LexString;											// string buffer
%}
%option noyywrap
%option yylineno
								/* extra lexer states: string/docstring parsing */
%x lexstring docstring
%%
#[^\n]*			{}											/* line comment */

															/* string parser */
'				{BEGIN(lexstring); LexString=""; }
<lexstring>'	{BEGIN(INITIAL); yylval.o = new Str(LexString); return STR; }
<lexstring>\\\\	{LexString+='\\';}
<lexstring>\\t	{LexString+='\t';}
<lexstring>\\n	{LexString+='\n';}
<lexstring>\n	{LexString+='\n';}
<lexstring>.	{LexString+=yytext[0];}
															/* docstring */
\"				{BEGIN(docstring); LexString=""; }
<docstring>\"	{BEGIN(INITIAL); yylval.o = new Str(LexString); return DOC; }
<docstring>.	{LexString+=yytext[0];}

[a-zA-Z0-9_]+		TOC(Sym,SYM)							/* symbol */

\(					TOC(Op,L)								/* brackets */
\)					TOC(Op,R)
\[					TOC(Op,LQ)
\]					TOC(Op,RQ)
\{					TOC(Op,LB)
\}					TOC(Op,RB)
															/* operators */
\=					TOC(Op,EQ)								/* assignment */
\@					TOC(Op,AT)								/* apply */
\:					TOC(Op,COLON)							/* inheritance */
\.					TOC(Op,DOT)								/* index */
\+					TOC(Op,ADD)								/* \ arithmetic */
\-					TOC(Op,SUB)
\*					TOC(Op,MUL)
\/					TOC(Op,DIV)
\^					TOC(Op,POW)								/* / */
\+\=				TOC(Op,INS)								/* ins \ composite */
\-\=				TOC(Op,DEL)								/* del / */

[ \t\r\n]+		{}									/* drop spaces */
%%
