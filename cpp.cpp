#include "hpp.hpp"
														// == error callback ==
#define YYERR "\n\n"<<yylineno<<":"<<msg<<"["<<yytext<<"]\n\n"
void yyerror(string msg) { cout<<YYERR; cerr<<YYERR; exit(-1); }

int main() { env_init(); return yyparse(); }			// == main() ==

void W(Sym*o)		{ cout<<o->dump(); }				// == writers ==
void W(string s)	{ cout<<s; }

											// == abstract symbolic type (AST) ==

Sym::Sym(string T,string V)		{ tag=T; val=V; }		// <T:V> constructor
Sym::Sym(string V):Sym("sym",V)	{}						// token constructor

void Sym::push(Sym*o)			{ nest.push_back(o); }	// add nest[]ed element
void Sym::setpar(Sym*o)			{ par[o->val]=o; }		// add par{}ameter

string Sym::pad(int n)	{ string S; for (int i=0;i<n;i++) S+="\t"; return S; }
string Sym::tagval()	{ return "<"+tag+":"+val+">"; }	// <T:V> header string
string Sym::dump(int depth) {							// dump symbol object
	string S = "\n"+pad(depth)+tagval();				// header
	for (auto pr=par.begin() ; pr!=par.end() ; pr++)	// par{}ameters
		S += ","+pr->first+":"+pr->second->tagval();
	for (auto it=nest.begin() ; it!=nest.end() ; it++)	// nest[]ed
		S += (*it)->dump(depth+1);
	return S;
}

Sym* Sym::eval() {
	Sym*E = env[val]; if (E) return E;					// lookup in glob.env[]
	for (auto it=nest.begin();it!=nest.end();it++)		// recurse eval()
		(*it) = (*it)->eval();
	return this;
}

Sym* Sym::eq(Sym*o)		{ env[o->val]=o; return o; }
Sym* Sym::at(Sym*o)		{ push(o); return this; }
Sym* Sym::dot(Sym*o)	{ setpar(o); return this; }

Directive::Directive(string V):Sym("",V) {				// == .directive ==
}
string Directive::tagval() { return "<"+tag+":'"+val+"'>"; }

														// == specials ==
Sym* nil = new Sym("nil","");							// nil

map<string,Sym*> env;									// == environment ==
void env_init() {										// init on startup
	env["nil"]=nil;
	// --------------------------------------------------- metainfo constants
	env["AUTHOR"]	= new Str(AUTHOR);			// author (c)
	env["LICENSE"]	= new Str(LICENSE);			// license
	env["GITHUB"]	= new Str(GITHUB);			// github home
	env["AUTOGEN"]	= new Str(AUTOGEN);			// autogenerated code signature
	env["LOGO"]		= new Str(LOGO);			// bI logo (w/o file extension)
	env["LISPLOGO"]	= new Str(LISPLOGO);		// Lisp Warning logo
	// functions
	fn_init();
}

														// == scalars ==
														// == string ==
Str::Str(string V):Sym("str",V) {}
//string Str::tagval()			{ return "<"+tag+":'"+val+"'>"; }
														// == machine numbers ==
Hex::Hex(string V):Sym("hex",V) {}						// hexadecimal
Bin::Bin(string V):Sym("bin",V) {}						// binary
														// == integer ==
Int::Int(string V):Sym("int","") { val = atoi(V.c_str()); }
string Int::tagval() {
	ostringstream os; os<<"<"<<tag<<":"<<val<<">"; return os.str(); }
														// == floating number ==
Num::Num(string V):Sym("num","") { val = atof(V.c_str()); }
string Num::tagval() {
	ostringstream os; os<<"<"<<tag<<":"<<val<<">"; return os.str(); }


														// == composites ==
List::List():Sym("[","]") {}							// [list]
Pair::Pair(Sym*A,Sym*B):Sym(A->val,B->val) {}			// pa:ir
Tuple::Tuple(Sym*A,Sym*B):Sym(",",",") {				// tu,ple
push(A); push(B); }
Vector::Vector():Sym("","") {}							// <vector>

														// == functionals ==
Op::Op(string V):Sym("op",V) {}							// operator
Sym* Op::eval() {
//	Sym::eval();										// nest[]ed evaluate
	if (nest.size()==2) {								// A op B bin.operator
		if (val=="=") return nest[0]->eq(nest[1]);
//		if (val=="@") return nest[0]->at(nest[1]);
//		if (val==".") return nest[0]->dot(nest[1]);
	}
	return this;
}
Fn::Fn(string V, FN F):Sym("fn",V) { fn=F; }			// == function ==
Sym* Fn::at(Sym*o) { return fn(o); }					// apply function
Lambda::Lambda():Sym("^","^") {}						// {la:mbda}


void fn_init() {							// == register internal functions ==
//	env["window"] = new Fn("window",window);
}
