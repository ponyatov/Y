%{
#include "bI.hpp"

#define TC(X)	{ yylval.c = yytext[0];     			return X; }
#define T1(X)	{ yylval.c = yytext[1];					return X; }
#define TS(X)	{ yylval.s = new string(yytext);     	return X; }
#define TO(C,X)	{ yylval.o = new biObject(C,yytext); 	return X; }
#define TX(C,X)	{ yylval.o = new C(yytext); 			return X; }
%}

%option noyywrap
%option yylineno

		/* expression mode */
%x ss

S	[\+\-]{0,1}
D	[0-9]+

%%
\r						{}							/* drop DOS eols */
#[^\n]*\n+				{}							/* line comment */
[ \t]+					TC(EOL)						/* drop spaces */

^\.[a-z]+[ \t]*/\{		TX(biDirective,DIRECTIVE)	/* {} blocked directive */
^\.end					TX(biDirective,END)			/* source end marker */
^\.[a-z]+[ \t]*[^\n]*	TX(biDirective,DIRECTIVE)	/* directive */

													/* prefixes */
\?						TC(EQ)						/* ? eval prefix */

[a-zA-Z][a-zA-Z0-9]*	TO("sym",SYM)				/* symbol */
													/* string */
\'[^\']*\'				TO("str",STR)
\"[^\"]*\"				TO("str",STR)
													/* numeric literals */
{D}						TX(biInt,NUM)				
0x[0-9A-F]+				TO("hex",NUM)
0b[01]+					TO("bin",NUM)
{D}\.{D}				TO("float",NUM)
{D}[eE]{S}{D}			TO("float",NUM)
													/* operators */
\+						TX(biOP,ADD)
\-						TX(biOP,SUB)
\*						TO("*",MUL)
\/						TO("/",DIV)
\^						TO("^",POW)
													/* parens */
\(						TO("(",LP)
\)						TO(")",RP)

\n+						TC(EOL)
.						TC(C)
%%

