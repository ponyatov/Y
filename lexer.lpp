%{
#include "bI.hpp"

#define TC(X)	{ yylval.c = yytext[0];     			return X; }
#define T1(X)	{ yylval.c = yytext[1];					return X; }
#define TS(X)	{ yylval.s = new string(yytext);     	return X; }
#define TO(C,X)	{ yylval.o = new biObject(C,yytext); 	return X; }
#define TX(C,X)	{ yylval.o = new C(yytext); 			return X; }
%}

%option noyywrap
%option yylineno

		/* expression mode */
%x ss

S	[\+\-]{0,1}
D	[0-9]+

%%
\\.						T1(C)						/* escaped char */
<*>#[^\n]*\n			{}							/* line comment */

^\.end					TS(END)						/* source end marker */
^\.[a-z]+[ \t]*/\{		TX(biDirective,DIRECTIVE)	/* {} blocked directive */
^\.file+[ \t]+[^\n]*	TX(biDirective,FFILE)		/* .file */
^\.eof					TX(biDirective,FEOF)		/* .eof */
^\.[a-z]+[ \t]*[^\n]*	TX(biDirective,DIRECTIVE)	/* directive */

<*>\'[^\']*\'			TO("str",STR)				/* 'string' */
<*>\"[^\"]*\"			TO("str",STR)				/* "string" */
													
{D}						TO("int",NUM)				/* numeric literals */
0x[0-9A-F]+				TO("hex",NUM)
0b[01]+					TO("bin",NUM)
{D}\.{D}				TO("float",NUM)
{D}[eE]{S}{D}			TO("float",NUM)

^class[ \t]+				{BEGIN(ss); TS(CLASS);}			/* class keyword */
<ss>\n\n					{BEGIN(INITIAL); TS(ENDCLASS);}
<ss>[ \t]+					{W(yytext);}					/* drop spaces */
<ss>[a-zA-Z][a-zA-Z0-9]*	TO("sym",SYM)					/* symbol */

<ss>:						TX(biOP,COLON)					/* : */
<ss>=						TX(biOP,EQ)						/* = */

\n						TC(EOL)						/* end line syntax marker */
.						TC(C)						/* any undetected char */
%%

