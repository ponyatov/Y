%{
#include "bI.hpp"

#define TC(X)	{ yylval.c = yytext[0];     			return X; }
#define T1(X)	{ yylval.c = yytext[1];					return X; }
#define TS(X)	{ yylval.s = new string(yytext);     	return X; }
#define TO(C,X)	{ yylval.o = new biObject(C,yytext); 	return X; }
#define TA(C,X)	{ yylval.o = new C(yytext); 		 	return X; }
#define TL(C,X) {\
	yylval.o = env[yytext]; \
	if (!yylval.o) {\
		yylval.o = new biObject(C,yytext);\
		env[yytext] = yylval.o;\
	}\
	return X;\
}
%}

%option noyywrap
%option yylineno

			/* S-expression */
%s ss		
			/* class definition */
%s cc		
			/* lexer defenition */
%s ll		

S	[\+\-]{0,1}
D	[0-9]+

%%
\.end						{ terminator(); }

\r							{}		/* win/dos eol gluck */
\\.							T1(C)	/* escaped char */
#[^\n]*						{}		/* line comment */

[a-z]+@[a-z\.]+				TS(S)	/* indoc email vs signal fix */

\$							{BEGIN(ss); TC(SX);}
\?							{BEGIN(ss); TC(QX);}
<ss>[ \t\n\.]				{BEGIN(INITIAL); TS(S); }
<ss,cc,ll>:					TC(COLON)
<ss,cc,ll>=					TC(EQ)
<ss,ll>,					TC(COMMA)
<ss>\(						TC(LP)
<ss>\)						TC(RP)
<ss,cc>{S}{D}				TO("int",NUM)
<ss,cc>0x[0-9A-Z]+			TO("hex",NUM)
<ss,cc>0b[01]+				TO("bin",NUM)
<ss,cc>{S}{D}\.{D}			TO("float",NUM)
<ss,cc>{S}{D}[eE]{S}{D}		TO("float",NUM)
<ss,cc>%N					TO("%N",SYM)
<ss,cc>%					TO("%",SYM)

^\.module[ \t]+[^\n]+			TA(biDirective,DOTMOD)
^\.file[ \t]+[^\n]+				TA(biDirective,DOTFILE)
^\.test[ \t]+[^\n]+				TA(biDirective,DOTTEST)
^\.[a-z]+[\+\-]?[ \t]*[^\n]*	TA(biDirective,DOT)

^class[ \t]+						{BEGIN(cc); TS(CLASS);}
<cc>\n\n							{BEGIN(INITIAL); TS(ENDCLASS); }

^lexer[ \t]+						{BEGIN(ll); TS(LEXER);}
<ll>\n\n							{BEGIN(INITIAL); TS(ENDLEX);}

<cc,ll>[ \t;\n]						{}

<ss,cc,ll>@[a-z0-9_\+\-\*\/]+			TO("sig",SIG)
<ss,cc,ll>[a-zA-Z_][a-zA-Z0-9_]*		TL("sym",SYM)

[ \t]*->[ \t]*				TS(ARROW)			/* -> cosmetics */

<ss,cc,ll>\'[^\']*\'		TA(biString,STR)

\n							TC(EOL)
.							TC(C)
%%

