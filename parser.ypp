%{
#include "bI.hpp"
%}

%defines

%union {
	char c;
	string *s;
	biObject *o;
}

%token	<c>	EOL C SX QX COLON COMMA LP RP BBEOL
%token	<s> S ARROW CLASS ENDCLASS LEXER ENDLEX
%token	<o> NUM SYM STR SIG DOT DOTFILE DOTMOD
%type	<o> ex pair list lexer rules class
%%
bI :
   	| bI SX ex					{ W($2); W($3->dump()); }
   	| bI SX list				{ W($2); W($3->dump()); }
	| bI QX ex					{ W($2); W($3->eval()); }
	| bI QX list				{ W($2); W($3->dump()); }
	| bI DOTFILE EOL			{ W($2->dump(),false); W($3,false); }
	| bI DOTMOD  EOL			{ W($2->dump(),false); W($3,false); }
	| bI class 					{ W(*$2->dump()); }
	| bI lexer 					{ W(*$2->dump()); }
	| bI ENDCLASS				{ W("\n"); } 
	| bI ENDLEX					{ W("\n"); } 
	| bI ex						{ W($2->dump()); }
	| bI ARROW					{ W(" -> "); /* -> cosmetics */}
	| bI EOL					{ W($2); }
	| bI C						{ W($2); }
	| bI S						{ W($2); }
;

class : 
	  CLASS SYM 				{ $$ = new biClass($2); }
	| class SYM					{ $$ = $1; $$->L.push_back($2); }
	| class pair				{ $$ = $1; $$->L.push_back($2); }
;

lexer : LEXER SYM rules			{ $$ = new biLexer($2); $$->L.push_back($3); }
;

rules : 				{ $$ = new biList(); }
	| rules list		{ $$ = $1; $$->L.push_back($2); }
;

list :
	  LP ex RP			{ $$=new biList($2); }
	| ex COMMA ex		{ $$=new biList($1); $$->L.push_back($3); }
	| list COMMA ex		{ $$=$1; $$->L.push_back($3); }
;

pair : ex COLON ex		{ $$=new biPair($1,$3); } 
;

ex :
	  NUM
	| STR
	| SIG
	| DOT
	| SYM
	| pair
;
%%

