%{
#include "sym.hpp"
#define TC(X)	{ yylval.c = new string(yytext);		return X; }	/* char */
#define TS(C,X)	{ yylval.s = new biSymbol(C,yytext); 	return X; } /* symbol */
%}

%option noyywrap
%option yylineno

		/* dotblock state */
%x about
%x sx
%x qx

%%
										/* priority source stream fixes */
[\r]			{}						/* drop DOS 0x0D endline component */
#[^\n]*\n		{W(yytext);}			/* line comment bypass */

										/* directives */

^\.about\{		{BEGIN(about); W(yytext);}		/* \ about */
<about>\}		{BEGIN(INITIAL); W(yytext);}	/* / block */

^\.end			TC(END)
^\.module		TS("directive",MODULE)	/* new/select current .module */
^\.file			TS("directive",FFILE)	/* inline .file */
^\.eof			TS("directive",FEOF)	/* end inline file */

^\.[a-z]+[^\n]*	{W(yytext);}		/* bypass any other.directive */

										/* mode selectors */
\$				{BEGIN(sx); TC(SX);}
\?				{BEGIN(qx); TC(QX);}
<sx,qx>[ \t\n]	{BEGIN(INITIAL);}
	
											/* basic language lexemes */
<sx,qx>\'[^\']*\'		TS("str",S)				/* string-defined symbol */
<sx,qx>\@[a-zA-Z0-9_]+	TS("@",S)				/* signal */

<sx,qx>class			TS("class",CLASS)		/* class creation keyword */
<sx,qx>[a-zA-Z0-9_]+	TS("sym",S)				/* generic symbol */
<sx,qx>[\+\-\*\/\<\>]	TS("op",S)				/* operators */

\n				TC(EOL)					/* endline marker */

.				{W(yytext);}			/* bypass any other undetected chars */
%%

